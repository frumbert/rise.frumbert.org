<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puzzle Game - Module Version</title>
  <script>
  class CountdownTimer {
    constructor(options = {}) {
      const {
        start = "60",
        end = () => {},
        tick = () => {}
      } = options;

      this.totalSeconds = CountdownTimer.parseTime(start);
      this.remaining = this.totalSeconds;
      this.onEnd = end;
      this.onTick = tick;
      this.interval = null;
    }

    static parseTime(str) {
      const parts = str.split(':').map(Number).reverse();
      let seconds = 0;
      if (parts[0]) seconds += parts[0];
      if (parts[1]) seconds += parts[1] * 60;
      if (parts[2]) seconds += parts[2] * 3600;
      return seconds;
    }

    start() {
      if (this.interval) return;
      this.interval = setInterval(() => {
        this.remaining--;
        if (typeof this.onTick === 'function' && this.remaining > -1) {
          this.onTick(this.remaining, (this.remaining/this.totalSeconds)*100, this.getTime() );
        }
        if (this.remaining <= 0) {
          if (typeof this.onEnd === 'function') this.onEnd();
          this.stop();
        }
      }, 1000);
    }

    stop() {
      clearInterval(this.interval);
      this.interval = null;
    }

    reset() {
      this.stop();
      this.remaining = this.totalSeconds;
    }

    getTime() {
      let s = this.remaining;
      const hours = Math.floor(s / 3600);
      s %= 3600;
      const minutes = Math.floor(s / 60);
      const seconds = s % 60;
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }
    }

  }
</script>
<style>
#source-element {
  display: none;
}

#puzzle-container {
  --cols: 4;
  --rows: 3;
  display: grid;
  grid-template-columns: repeat(var(--cols), 1fr);
  grid-template-rows: repeat(var(--rows), 1fr);
  aspect-ratio: 16 / 9;
  width: 80vw;
  max-width: 100vw;
  position: relative;
  margin: auto;
  background: black;
  box-shadow: 0 0 1rem #00000040;
  transition: gap 1s ease;
  gap: 1rem;
  &.done { 
    gap: 0;
  }
}

.puzzle-piece {
  position: relative;
  overflow: hidden;
  display: block;
  cursor: grab;
}

.puzzle-piece > * {
  position: absolute;
  width: calc(var(--cols) * 100%);
  height: calc(var(--rows) * 100%);
  top: calc(-1 * var(--row) * 100%);
  left: calc(-1 * var(--col) * 100%);
  object-fit: cover;
  pointer-events: none;
  clip-path: var(--clip);
}

#puzzle-container.dragging > *:not(.sortable-swap-highlight) {
  filter:grayscale(.5);
}

.graph { width: 80vw; max-width: 100vw; display: flex; gap: 1rem; margin: 1rem auto; align-items: center; }
.graph meter { flex: 1; }
.graph button { display: none; }

meter::-webkit-meter-optimum-value, meter::-webkit-meter-suboptimum-value, meter::-webkit-meter-even-less-good-value {
    transition: .5s width;
}

</style>

</head>
<body>

<div id="puzzle-container" data-tiles="5x5" data-src="#source-element" data-timer="1:10"></div>
<div class="graph"><label for="remaining"></label><meter id="remaining" min="0" max="100" low="10" high="50" optimum="90" value="0"></meter><button></button></div>

<img id="source-element" src="https://images.unsplash.com/photo-1623184502217-d5e1cab9363b?q=80&w=1770&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" />

<!-- Use the module injection script -->
<script type="module" src="module-injection.js"></script>

</body>
</html>